In this next lab, we'll build out something more powerful than what we did in our previous lab. We'll set up a highly available SQL server cluster in GCE. In this demo, we'll make use of Google Cloud Launcher to provision a SQL Server Enterprise AlwaysOn Cluster. Cloud Launcher will automate the creation of multiple windows virtual machines, one Windows Server and two SQL Server instances. It will also configure Active Directory and Google's virtual private cloud network with a topology that's optimized for rapid fail over of the SQL Server AlwaysOn Cluster. Once we've done that, we'll test fail over. You can see that I'm already logged in to Google Cloud Platform, using my Google account, and I'm looking at the Cloud Console. I'm looking at the page which is for Cloud Launcher. We can find that from the Products and services menu, and there it is. Right near the top. Cloud Launcher provides a set of solutions. Each solution automates configuration of virtual machines or containers. Of particular interest to Windows developers and operations staff on Google Cloud platform, we have the SQL Server solution. So, let's find that by typing SQL Server into the search box. Notice how we get one search result. The SQL Server AlwaysOn cluster. When we select this result, we'll see the details page for this solution. One thing to note, is that this demo provisions multiple virtual machines, each with a premium image. So, the cost at the time of presentation using the default options is round about $3000 per month. This includes the cost of the Windows Server and SQL Server licenses, as well as the virtual machine resources you'll be using. However, this is a true enterprise solution providing high availability of SQL Server with fail over, reflect on how much this will cost to provision in an on premises environment. Okay. So, I've clicked on the Launch On Compute Engine button, and now we get to look at the default configuration. Notice, how we have to choose our Active Directory domain, and I'm going to choose demo.com. The rest of the options will leave as their defaults, and then we can scroll to the bottom of the form and click on deploy. This will take round about 30 minutes to provision, all of the infrastructure that's needed. You'll notice that we've now switched over to cloud deployment manager. I'll pause the video until this deployment completes. Okay. We're back. Now, we're looking at the Deployment Manager page, with a SQL Server AlwaysOn Cluster, that's already been deployed. This is actually a cluster that I deployed earlier. When we're done with our solution, we could check the box and simply click the delete button, and all of the resources associated will automatically be deleted as well. Now, we need to test our AlwaysOn Cluster. Terms of the machines that have been provisioned in our cluster. If we switch over to Compute Engine, then we'll notice that they have been three machines that have been created. We have our two SQL Server machines, and we have an Active Directory machine. I've installed Microsoft SQL Server management studio onto the Active Directory machine, so that we can connect it to a SQL Server and verify fail over. So, let's go over to that machine now. So, here we are connected into our Active Directory machine. And we have added a connection to a virtual IP address that's being created for us by the clustering infrastructure. And in the solution deployment, this IP address is associated with this DNS name cluster-listener. So we just connect using a regular SQL Server connection window, and we'll be connected up to the AlwaysOn Availability Cluster. The other thing to notice is that a database has been provisioned within that cluster and has already been synchronized between the two machines in the cluster. This is called TestDB. And if we scroll down to the AlwaysOn High Availability cluster section, then you'll notice that we have our availability replicas with one machine as the primary, and the other machine as the secondary. If we expand that Availability Databases, then we can see our TestDB has being replicated within the cluster. So, now we can just design a database, and this is just a regular system's operation task. So, create a table. I'm modeling an application which records where I like to eat in countries all around the world. So, I'm going to create a table called restaurants, it's going to have an ID. The data type for that is going to be an integer. That's going to be the primary key column for our database. And we'll also set this column, so that it is the identity column for the table as well. So, the identity specification here, we'll switch that, so that its the identity column. Some more columns in here, so I need my restaurant name. We'll make this into an nvarchar50, in fact we'll make all of the rest of the field into nvarchar50, which will just to make things easier as we type in the column names. City, that's an nvarchar50 as well, and we're going to have the cuisine, this will be an nvarchar50. And then finally the price range, maybe like low, medium, or high, or something like this. That can be an nvarchar50 too. That completes the design of our database. We'll save that and give that table a good name. It's going to be called restaurants and of course this could be a much more complex scheme, but that will do for now. So the next thing that we need to do is to add some data into that table. We just refresh our tree view on the left hand side, is our restaurants table. And if we right click on this then we'll be able to edit some records inside that table. So, I'll put a couple of restaurants in here. First form is one of my favorite places to eat in London. This is called Honey and Co. The cuisine is from the Middle East and the price range, well it's very reasonable, so I'll put moderate in here. And then for the next one, we'll put in Shake Shack, everyone's favorite burger. I've been in Shake Shack in loads of places, but we'll say that that's NYC, it's a classic American burger and the price range is low. And you'll notice that as we add these records, then the Id's are automatically generated as well. Now, the next fun thing to do is to test fail over. So, let's take our primary database offline and we'll do this as if it was an unplanned fail over where the machine has failed all of a sudden. So, I'm going to go back over to the cloud console and we'll just simply shut that machine down and then we'll see what happens. So, here I am back in the Cloud Console. This is our primary machine. So, we'll select this and then just stop it. When this machine stops, then obviously it can't be the primary anymore. We should be able to return back to our client machine. And typically, we'll see fail over with the network configuration that's being setup, as part of the solution within around 15 seconds so it's incredibly quick. And typically, most clients applications will be configured to retry occasionally in the event of a connection failure, so it's unlikely that those clients would even see any downtime within our AlwayOn Availability Cluster. Let's go back over to that machine and see what's going on. Okay, so here we are over on that machine and if we take our availability replicas section of the tree view and we refresh, then you'll notice that we have our new primary here. This is the mssql-dem-sql-2 machine which is now identified as the primary, and the secondary machine is marked as down. We come back into the client application. Another place I like to eat when I'm in NYC is in Momofuku Noodle bar, that's in NYC, cuisine is Asian, prices pretty good, so I'm going to put moderate in for that one as well. And the thing I want you to notice is that when we committed those records then that was completely seamless from the perspective of the client application. We also notice that the Id here, is not completely sequential from the previous identity Id. So, that's kind of interesting too. Let's go back and start up the machine that's failed over and then we'll be able to return and observe that the machine will be restarted and form parts of the AlwaysOn Availability Cluster without us having to do any more configuration work. So, here I am back in the cloud console. We'll simply start that machine back up again. And as soon as that machine is booted, it will rejoin the AlwaysOn Availability Cluster, and the cluster will be restored to having a primary and an active secondary as well. So, that's pretty good. So our machine has booted and in just a few seconds, when we return back the client's application, then we'll be able to observe that both machines are now present in the cluster. Here we are back in Microsoft SQL Server management studio once again, in our availability replicas. If we select to refresh, well, that machine hasn't quite showed up yet. Let's just wait a few more seconds and then we'll try it again. We should see that we now have two machines primary and secondary, that are both up. And there we are. We've now got two machines that are running in our AlwaysOn Availability Cluster. That completes the demo. In this demo, we've created the Windows and SQL Server Infrastructure to support a high availability SQL Server environment. Then shown how our application will fail over very quickly.